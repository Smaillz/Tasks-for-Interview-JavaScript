/** 
    Сколько существует способов отправить запрос на сервер(предположим мы открыли пустую вкладку и консоль разработчика)
    
    1) XmlHttpRequest
    2) fetch
    3) с пом тега script ли img (возможно и с iframe)
    4) WebSocket
    5) создать form  и сделать submit
    6) метод navigator.sendBeacon() - отправить маяк
*/

//можно отправить небольшое количество данных с помощью 
navigator.sendBeacon('https:/api.nestoria.co.uk/api?action=echo&encoding=json&callback=bar');

// флаг HttpOnly(связанно с куками)
// https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%9A%D1%83%D0%BA%D0%B8

/**
    Мы вводим в браузере запрос map.google.com и что происходить дальше?

    1) Браузер смотрит это запрос или адрес удаленного ресурса, если запрос, то отправляет в поисковую систему по умолчанию
    если адрес то лезет в файл hosts и смотрит есть ли ip нужного ресурса
    2) если в hosts ничего не найдено формирует запрос и отправляет в сеть
    3) там запрос с помощью маршрутизаторов идет до сервера(задача состоит в том чтобы по доменному имени найти нужный ip адрес
        путем разбора map google com где com - рут домен, google - домен 1-го уровня и тд, сначала узнает где .com идет туда
        там узнает где поддомен google и т.д.) где мы получаем IP адрес нужного нам ресурса
    4) На запрос сервер отдает то что нужно(например html страницу)
    5) Браузер получает страницу html и начинает ее парсить
    6) Происходит рендеринг содержимого пользователю

    Стадии критического пути рендеринга
        https://habr.com/post/320430/
    Способы сделать загрузку css неблокирующей
        https://webformyself.com/obrabatyvaem-blokiruyushhij-rendering-css-dlya-uskoreniya-renderinga-sajta/
 */

/* fetch VS XMLHttpRequest */
//Пример fetch API
fetch('https://api.example.com/user', {
    mode: 'cors',
    method: 'POST',
    credentials: 'include',
    body: JSON.stringify(details),
    headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-XSRF-TOKEN': getCookieValue('XSRF-TOKEN')
    }
}).then(response => {
    return response.json().then(data => {
        if (response.ok) {
            return data;
        } else {
            return Promise.reject({
                status: response.status,
                data
            });
        }
    });
});
//Пример XMLHttpRequest
function success() {
    var data = JSON.parse(this.responseText);
    console.log(data);
}

function error(err) {
    console.log('Error Occurred :', err);
}

var xhr = new XMLHttpRequest();
xhr.onload = success;
xhr.onerror = error;
xhr.open('GET', 'https://api.github.com/users/test');
xhr.send();

/*
Есть несколько вещей, которые вы можете сделать с fetch, а не с XHR:
    - Использует промисы
    - Вы можете использовать Cache API с объектами запроса и ответа;
    - Вы можете выполнять no-cors запросы, получая ответ от сервера, который не поддерживает CORS. Вы не можете получить доступ к телу ответа напрямую из JavaScript, но вы можете использовать его с другими API (например, Cache API);
    - Потоковые ответы (с XHR весь ответ буфферизируется в памяти, с помощью fetch вы сможете получить доступ к низкоуровневому потоку). Это доступно не во всех браузерах, но скоро будет.
+ в fetch API неудобная с точки зрения разработчиков  обработка ошибок т.е 
    Fetch отвергнет обещание только если произошла сетевая ошибка (DNS не разрешил адрес, сервер недоступен, CORS не разрешен).
    В остальных случаях ошибки не будет (включая HTTP статусы 404 или 500), поэтому для получения более интуитивного поведения 
    такие ситуации придётся обрабатывать вручную.
 */
fetch(url)
    .then(response => {
        return response.json().then(data => {
            if (response.ok) {
                return data;
            } else {
                return Promise.reject({status: response.status, data});
            }
        });
    })
    .then(result => console.log('success:', result))
    .catch(error => console.log('error:', error));
/*
С XHR вы можете сделать несколько вещей, которые вы еще не можете сделать с fetch, но они будут доступны рано или поздно 
    - Прервать запрос(в XHR abort())(уже есть поддержка для fetch - controller = new AbortController(); const signal = controller.signal; ну и само прерывание через controller.abort() );
    - Наблюдать за прогрессом выполнения запроса.
*/


// get vs post
/*
GET
    - запрос в котором параметры передаются в самом url-е(https://api.github.com?param=1&para2=2)
    - могут кешироваться
    - нет тела запроса (на сомом деле может быть, в спецификации про это не слово, вопрос лишь в том как такой запрос обработает сервер)
    - по REST предполагает действие READ(CRUD)
    - т.к. все находится в адресе запроса(сам адрес + параметры) имеет ограниченную длину(зависит от сервера или браузера(от 2 до 8 КБ))
POST
    - не кешируется(т.к. предполагается что он может изменять какие-то данные,  а с сохраненными данными в кэш что-то может пойти не так)
    - содержит тело запроса
    - по REST предполагает действие UPDATE/CREATE(CRUD)
    - если используется протокол https то тело дополнительно шифруется при передаче
*/

/* немного про кеширование
    no-cache - принуждает кэш отправлять запрос на исходный сервер каждый раз для валидации, прежде чем выдать кэшированную копию.
        Это полезно, когда необходимо гарантировать, что аутентификация принята во внимание (в сочетании с public) или для поддержания жесткой свежести без потери преимуществ кэширования.
    no-store - указывает кэшу не сохранять копию контента, ни при каких условиях.

    Кэш браузера (Browser cache)
        Если вы изучите окно настроек любого современного веб-браузера (например, Internet Explorer, Safari или Mozilla), вы, вероятно, заметите параметр настройки «Кэш».
        Эта опция позволяет выделить область жесткого диска на вашем компьютере для хранения просмотренного ранее контента. Кэш браузера работает согласно довольно простым правилам. 
        Он просто проверяет являются ли данные “свежими”, обычно один раз за сессию (то есть, один раз в текущем сеансе браузера).
        Этот кэш особенно полезен, когда пользователь нажимает кнопку “Назад” или кликает на ссылку, чтобы увидеть страницу, которую только что просматривал. 
        Также, если вы используете одни и те же изображения навигации на вашем сайте, они будут выбираться из браузерного кэша почти мгновенно.

    Как работает веб-кэш
        - Если заголовки ответа сообщают кэшу не сохранять их, он не сохранит.
        - Если запрос авторизованный (authorized) или безопасный (то есть, HTTPS), он не будет закэширован.
        - Кэшированный контент считается “свежим” (то есть, может быть отправлен клиенту без проверки с исходного сервера), если:
            - У него установлено время истечения или другой заголовок, контролирующий время жизни, и он еще не истек.
            - Если кэш недавно проверял контент и тот был модифицирован достаточно давно.
            Свежий контент берется непосредственно из кэша, без проверки с сервера.
        - Если контент является устаревшим, исходному серверу будет предложено провалидировать его или сообщить кэшу, является ли имеющаяся копия по-прежнему актуальной.
        - При определенных обстоятельствах — например, когда он отключен от сети — кэш может сохранять устаревшие ответы без проверки с исходного сервера.
*/

